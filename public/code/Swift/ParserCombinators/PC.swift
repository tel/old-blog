func id  <A>(a: A)      -> A { return a }
func fix <A>(f: A -> A) -> A { return f(fix(f)) }
func loop<A>()          -> A { return fix(id) }

protocol Viewl {
    typealias El
    func uncons() -> (El, Self)?
}

func head<X:Viewl>(x: X) -> X.El? { return x.uncons()?.0 }
func tail<X:Viewl>(x: X) -> X?    { return x.uncons()?.1 }

func leftArray<S:Viewl>(n: Int)(s: S) -> [S.El] {
    var res:[S.El] = []
    var s_  = s
    for i in 0..<n {
        if let (a, ss) = s_.uncons() {
            res += a
            s_  = ss
        } else { break }
    }
    return res
}

func leftStream<S:Viewl>(s: S) -> Stream<S.El> {
    if let (x, xs) = s.uncons() {
        return Stream { return (x, leftStream(xs)) }
    } else { return Stream.empty() }
}

// Convert a String into a Stream of characters
func streamString(s: String) -> Stream<Character> {
    // return Stream(project: { opt(second(streamString))(maybeA: s) })
    return Stream {
        if let (c, cs) = s.uncons() {
            return (c, streamString(cs))
        } else { return nil }
    }
}

extension String:Viewl {
    typealias El = Character
    func uncons() -> (Character, String)? {
        return isEmpty ? nil : (self[startIndex], dropFirst(self))
    }
}

extension Array:Viewl {
    typealias El = Element
    func uncons() -> (Array.Element, Array)? {
        return isEmpty ? nil : (self[0], Array(dropFirst(self)))
    }
}

class Ptr<T> { let val: T; init(_ aVal:T) { val = aVal } }

// Lazy, potentially-infinite Streams in Swift
struct Stream<A>:Viewl {

    typealias El = A
    
    // Internal use only---use the initializer to write a more natural
    // unfold which ignores the use of Ptr
    let project: () -> (A, Ptr<Stream<A>>)?

    init(p: () -> (A, Stream<A>)?) {
        project = {
            if let (a, s) = p() {
                return (a, Ptr(s))
            } else { return nil }
        }
    }

    
    // Generated by an unfold
    func uncons() -> (El, Stream)? {
        if let (x, a) = project() {
            return (x, a.val)
        } else { return nil }
    }

    
    // Transformed by folds
    func scott<R>(z: R, f: (A, Stream<A>) -> R) -> R {
        if let (a, s) = uncons() { return f(a, s) } else { return z }
    }

    func fold<R>(z: R, f: (A, R) -> R) -> R {
        return scott(z, { (a, s) in f(a, s.fold(z, f)) })
    }


    // Standard constructions
    static func empty() -> Stream<A> { return Stream { nil } }

    static func pure(a: A) -> Stream<A> {
        return Stream { return (a, Stream.empty()) }
    }

    // Combining streams
    func append(s: Stream<A>) -> Stream<A> {
        return Stream { self.scott(s.uncons(), { (a, ss) in (a, ss.append(s)) }) }
    }
    
    func then<B>(f: A -> Stream<B>) -> Stream<B> {
        return scott( Stream<B>.empty(), { (a, s) in f(a).append(s.then(f)) } )
    }

    func take(n: Int) -> Stream<A> {
        switch n {
        case 0: return Stream.empty()
        case _:
            if let (a, s) = uncons() {
                return Stream { return (a, s.take(n-1)) }
            } else { return Stream.empty() }
        }
    }
}

func upFrom(n: Int) -> Stream<Int> {
    return Stream {
        return (n, upFrom(n+1))
    }
}

func maybe<A,R>(z: R, f: A -> R)(m: A?) -> R {
    if let a = m { return f(a) } else { return z }
}

//struct Parser<A> {
//    let parse: String -> [(A, String)]
//    
//    static func pure(a: A) -> Parser<A> {
//        return Parser(parse: { s in [(a,s)] })
//    }
//    
//    func then<B>(f: A -> Parser<B>) -> Parser<B> {
//        return Parser(
//            parse: { s in
//                parse(s).then { res in
//                    
//                }
//            }
//        )
//    }
//}

//func satisfy(p: Character -> Bool) -> Parser<Character> {
//    return Parser({ s1 in
//        if let (c, s2) = s1.uncons() {
//            if p(c) {
//                return [(c, s2)]
//            } else {
//                return []
//            }
//        } else {
//            return []
//        }
//    })
//}
//
//satisfy({c in c == "h"}).parse("hoo")
//satisfy({c in c == "h"}).parse("doo")
